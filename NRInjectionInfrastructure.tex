\documentclass[aps,prd,amssymb,amsmath,amsfonts,superscriptaddress,
floatfix ,preprintnumbers,altaffilletter]{revtex4}

\usepackage{epsfig}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,mathrsfs}
\usepackage{amsfonts}
\usepackage{color}
\usepackage{wasysym}
\usepackage{times}
\usepackage{mathptmx}
\usepackage{gensymb}
%\usepackage{fullpage}
\usepackage{appendix}
%\usepackage{fontenc}
\usepackage{listings}
%\usepackage[utf8]{inputenc}
%\usepackage{authblk}
\usepackage{listings}

%%%%%Some new commands%%%%%%%%%%%%%%%%%
\newcommand{\patricia}[1]{\textcolor{blue}{\textit{Patricia: #1}}}
\newcommand{\ian}[1]{\textcolor{blue}{\textit{Ian: #1}}}

\newcommand{\AEI}{Max Planck Institute for Gravitational Physics (Albert-Einstein-Institute), Am M\"uhlenberg 1, Potsdam-Golm, 14476, Germany}
\newcommand{\Ligo}{LIGO Laboratory, California Institute of Technology, MS 100-36, Pasadena, California 91125, USA}
\newcommand{\TAPIR}{Theoretical Astrophysics, Walter Burke Institute for Theoretical Physics, California Institute of Technology, Pasadena, California 91125, USA}
\newcommand{\CITA}{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%
\begin{document}
%%%%%%%%%%

\title{Numerical Relativity Injection Infrastructure}

\author{Patricia Schmidt}
\affiliation{\Ligo}
\affiliation{\TAPIR}

\author{Ian W. Harry}
\affiliation{\AEI}

\author{Harald P. Pfeiffer}
\affiliation{\AEI}
\affiliation{\CITA}

\date{\today}

\begin{flushright}
LIGO-T1500606-v1
\end{flushright}

%%%%%%%%%%%%%%%
\begin{abstract}
\label{sec:abs}
%%%%%%%%%%%%%%%
This document describes the new standardised NR injections infrastructure in the LIGO Algorithms Library (LAL), 
which henceforth allows for the usage of Numerical Relativity (NR) waveforms as a discrete waveform approximant
in LAL. With this new interface, NR waveforms provided in the appropriate format can directly be
used as mock GW signals (``injections'') for LIGO data analyses, which include parameter estimation, searches, hardware
injections etc. The interface handles higher-order modes making them directly accessible to LIGO data analyses for
the very first time. 
\end{abstract}

%%%%%%%%%%%%%%%
\maketitle 

%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:intro}
%%%%%%%%%%%%%%%
Recently, LIGO has reported the first detection of gravitational waves (GW) from a merging binary black hole system~\cite{}.
Such coalescing compact binaries are prime sources for the ground-bases interferometric GW detectors and play a critical role in LIGO data analysis. Whilst for low-mass systems only the early part of the binary evolution, the inspiral, is accessible to LIGO, for high-mass systems 
also the later stages, in particular the merger and ringdown of the final black, are visible in LIGO's sensitivity band. 

During the early part of the binary coalescence, the emitted gravitational waveforms are accurately described by an
analytic post-Newtonian expansion of the Einstein field equations~\cite{}. 
To obtain the waveforms for the final stages, the full non-linear solutions
of the field equations are required~\cite{}, which are provided by Numerical Relativity (NR).
Regarding the usage of NR waveforms for LIGO data analysis, so far, NR merger waveforms have predominantly been used to calibrate the merger-ringdown section of analytic waveform models which describe the complete inspiral-merger-ringdown (IMR) signal~\cite{}, to test such models against independent NR waveforms not used in the construction~\cite{} and to determine the physical properties of the remnant black hole~\cite{}.

In the Advanced detector era, however, we want to be able to directly use NR waveforms in gravitational-wave searches
and parameter estimation, to test General Relativity and to assess the systematics of analytic waveforms models within
a uniform framework. 
This is know possible with the recently implemented  simple infrastructure, which allows for the treatment of
NR waveforms as a ``discrete'' waveform approximant provided the NR data are available in a \emph{specific format}. 

In previous efforts, BBH hybrid waveforms constructed by combining a PN inspiral with an NR merger-ringdown 
waveform, have been used in LIGO data analysis and parameter estimation in the NINJA and NINJA-2 projects~\cite{Aylott:2009ya, Aasi:2014tra}. These hybrids only contained the dominant harmonics, the $(\ell, |m|) =(2,2)$ modes, and required the NR waveforms to be linearly interpolated and resampled at uniform times for a given sampling rate $f_s$. In the NINJA framework, the resampling was performed 
 \emph{before} inserting the total mass scale, resulting in very memory-intensive operations, since the finest $\Delta t$ for a given $f_s$ is determined by the highest total mass one wants to be able to resolve.
  
The new infrastructure handles this differently, in the following way: Firstly, since it naturally handles higher-order modes, it uses a highly compressed data format to represent the NR data to reduce the storage requirements and reduce I/O time. 
Secondly, the compressed NR data are interpolated using 1D spline interpolation, and the resulting interpolants are evaluated \emph{after} the mass scale has been inserted. This avoids high-memory operations and also bypasses the need to store unnecessarily large data files.
The new injection infrastructure fully implemented in LAL and supersedes any previously used NR modules.

The remainder of this technical document is organised as follows: In Sec. \ref{sec:format} we provide a brief summary
of the NR data format and metadata required as input. In Sec. \ref{sec:gen} we describe the basics of the waveform generation code and give explicit examples of how the NR waveforms are evaluated in lalsimulation/pycbc. 
We highlight caveats and desired future improvements in Sec.~\ref{sec:discussion}.

%%%%%%%%%%%%%%%
\section{Waveform Format}
\label{sec:format}
%%%%%%%%%%%%%%%
In Numerical Relativity one solves for the complete space-time of the binary system. For data analysis
purposes however, one requires the gravitational-wave strain $h(t)$ far from the source. The relevant numerical quantity
is the metric perturbation $h^{TT}_{ij}$ as computed in the transverse-traceless gauge (TT). 

There are different way of computing the metric perturbation from a numerical evolution. The most common methods include
the use of the complex Weyl scalar $\Psi_4$, which is related to the metric perturbation via two time derivatives, or the
Regge-Wheeler-Zerilli formalism computes the metric perturbation in the wave-zone as a perturbation of the Schwarzschild
spacetime. 

In the TT gauge, the metric perturbation
has two independent real polarisations, $h_+$ and $h_\times$, which can be written as a complex strain by
\begin{equation}
\label{ }
h = h_+ - i h_\times \in \mathbb{C},
\end{equation}
where $h_+, h_\times \in \mathbb{R}$.

Let $(t,x,y,z)$ be a Cartesian coordinate system in the wave-zone, which is related to the polar coordinates $(r, \theta, \phi)$ by the standard means. In this coordinate system, the metric perturbation is commonly decomposed into \emph{modes}
in a basis of spin-weighted spherical harmonics, ${}^{-2}Y_{\ell m}$, of spin weight $s=-2$, where the GW propagation direction is
the radial unit vector r.
For any point $(\theta, \phi)$ on the unit sphere, the GW strain can then be shown to take the following form:
\begin{equation}
\label{ }
h(t; \theta, \phi) = h_+ - i h_\times = \sum_{\ell=2}^\infty \sum_{m=-\ell}^{\ell} h_{\ell m}(t) {}^{-2}Y_{\ell m}(\theta,\phi).
\end{equation}
As for any wave, we can also write each gravitational-wave mode $h_{\ell m}$ as an amplitude $A_{\ell m}$ and a phase
$\Phi_{\ell m}$,
\begin{equation}
\label{ }
h_{\ell m}(t) = A_{\ell m}(t)e^{i\Phi_{\ell m}(t)}.
\end{equation}
The amplitude of each mode is its complex norm, the phase is the unwrapped argument of the complex time series $h_{\ell m}$. 

%%%%%%%%%%%%%%%
\subsection{Spline Compression}
\label{sec:spline}
%%%%%%%%%%%%%%%
Gravitational waveforms for LIGO data analysis purposes require uniform sampling in time for a given sampling frequency $f_s$.
NR datasets however, are commonly not uniformly sampled and if they are, the sampling interval $dt$ may not necessarily
correspond to the one required by data analysis tools. 
It is therefore unavoidable to interpolate the NR data such that for any total
mass M and sampling rate the NR waveforms can be resampled accordingly. Whilst the NR data could simply be interpolated as
they are, we choose to reduce the data by performing 1D spline compression on the NR data~\cite{Galley:2015aa}. This is a particular advantage for long simulations or hybrid PN-NR data, but also significantly reduces the storage and I/O for pure NR data. It is mandatory that the NR data files are provided in the correct compressed file format, which is as follows: \\
\\The 1D spline compression is performed separately for each mode amplitude $A_{\ell m}$ and phase $\Phi_{\ell m}$. The compression is
achieved by applying a greedy algorithm to the NR data, which selects the near-optimal points to construct a univariate spline interpolant
with a specified global accuracy. By default, the interpolants are constructed using fifth degree polynomials and a tolerance of $10^{-6}$,
i.e. if the spline is evaluated at the discrete times $t_i$ of the NR data, the original NR values are recovered with an error smaller than the
specified tolerance. For a detailed description of this method and the accuracy of the obtained interpolants, we refer the reader to~\cite{Galley:2015aa}. The spline compression is performed using the publicly available python package ``romSpline'' by Chad R. Galley~\cite{} [https://bitbucket.org/chadgalley/romspline]. \\
\\The spline interpolants for each amplitude and phase are obtained via \texttt{romSpline.ReducedOrderSpline()} as follows:
\begin{lstlisting}
import romSpline
spline = romSpline.ReducedOrderSpline(time_data, amplitude/phase_data, verbose=False)
spline.write('filename.h5')
\end{lstlisting}
Note: a newer version of romSpline now also allows to pass a group descriptor, i.e. writing to file as intermediate step may be avoided.

Once the spline interpolants have been obtained, they have to be stored as individual groups in a \emph{single HDF5 file} with the following mandatory group naming conventions: 
\begin{itemize}
  \item Amplitude group: \textbf{amp\textunderscore l\#1\textunderscore m\#2}
  \item Phase group: \textbf{phase\textunderscore  l\#1\textunderscore m\#2},
\end{itemize}
where (\#1, \#2) are placeholders for $(\ell, m)$, e.g., for $(\ell=2, m=-2)$ the naming convention is phase\textunderscore l2\textunderscore m-2 and 
amp\textunderscore l2\textunderscore m-2. \\
\\Pure NR data without a hybridised PN inspiral need to have the initial \emph{junk radiation} removed before the spline interpolants are constructed but no tapering should be applied at the beginning or end of the waveform data. Following the LAL waveform convention, the waveforms also need to be aligned such that the peak of the waveform occurs at $t_\mathrm{peak}=0$ before constructing the interpolants. In addition to the amplitude and phase groups, we highly recommend to also include the NR times as a group in the HDF5 file. 

%%%%%%%%%%%%%%%
\subsection{Metadata}
\label{sec:meta}
%%%%%%%%%%%%%%%
The metadata format is adapted from the original NINJA-2 metadata format~\cite{Brown:2007jx}, and whilst then metadata were stored an additional text file, it is now mandatory that each HDF5 contains a \emph{minimal} set of metadata stored as \emph{attributes} of the HDF5 file. 
If a metadata text file exists, however, we recommend that it is additionally included in the HDF5 file.

In the current implementation, the required metadata (see list below) contain the values associated with the first entry in the data. For pure NR data, since the junk radiation has to be removed, these data are not the initial data of the simulation. We refer to this very first data point stored in the HDF5 file as the \emph{beginning} of the waveform. 

Further, the spin measurements \emph{and} the orbital phase at the beginning of the waveform have to be provided as measured in a very specific binary source frame, namely in one where the instantaneous orbital plane
defines the xy-plane and $\hat{L}$ points along the z-axis (see Fig.~\ref{fig:source} for an illustration). Note that this may involve some transformation of spin data depending on the NR code. However, the waveform data are unchanged.

More metadata can be added as desired but the minimal requirements are the following: \\
\begin{itemize}
\item {[}NR-group{]}: a string to identify the NR group/code
\item {[}type{]}: a brief description of the simulation, e.g. aligned-spins, precessing etc.
\item{[}name{]}: list here alternative names or internal identifiers of the simulation
\item{[}eta{]}: the symmetric mass ratio of the binary system
\item{[}f\textunderscore lower\textunderscore at\textunderscore 1MSUN{]}: frequency of the $(2,2)$-mode in Hz at the beginning of the waveform scaled to 1 solar mass
\item{[}coa\textunderscore phase{]}: this is twice the orbital reference phase at the beginning of the waveform
\item{[}spin1x{]}, {[}spin1y{]}, {[}spin1z{]}: spin components of the spin on the larger object measured w.r.t. to the orbital angular momentum L at the beginning of the waveform
\item{[}spin2x{]}, {[}spin2y{]}, {[}spin2z{]}: spin components of the spin on the smaller object measured w.r.t. to the orbital angular momentum L at the beginning of the waveform
\end{itemize}
To reduce potential ambiguities and to enable the usage of waveforms from matter simulations, we further recommend adding the following  additional metadata:
\begin{itemize}
\item{[}object1{]}, {[}object2{]}: a string to identify the object type, e.g. black hole, neutron star
\item{[}mass1{]}, {[}mass2{]}: matter simulations have a mass scale, hence not only the mass ratio but also the individual masses need to be accessible
\item{[}eccentricity{]}: eccentricity parameter of the simulation
%\item{[}NR\textunderscore frame{]}: the coordinate system , e.g. inertial, J-aligned etc.
\item{[}J\textunderscore hat{]}: the direction of the total angular momentum at the beginning of the waveform
\item{[}L\textunderscore hat{]}: the direction of the orbital angular momentum at the beginning of the waveform
\item{[}PN\textunderscore approximant{]}: string identifier for the inspiral if hybrid data are stored
\end{itemize}
For complete reproducibility and transparency, we recommend to store any NR metadata files and the original NR times $t_i$ as a datasets in the HDF5 file.

%%%%%%%%%%%%%%%
\section{Generating NR waveforms}
\label{sec:gen}
%%%%%%%%%%%%%%%
Once the HDF5 file has been provided, the NR waveforms can be generated through the standard waveform interfaces \texttt{ChooseTDWaveform()} in LAL
and \texttt{get\textunderscore td\textunderscore waveform()} in pyCBC~\cite{Canton:2014ena}. The lal approximant name is ``NR\textunderscore hdf5''. To call the test verification code in pycbc, specify the approximant ``NR\textunderscore hdf5\textunderscore pycbc''. 
As opposed to continuous approximants, the spline data are read from file and evaluated for the desired extrinsic
parameters. The intrinsic parameters in NR simulations are fixed, currently internal checks on the mass ratio and the spin components 
are performed to guarantee the consistency between the values passed
in the waveform generation call and metadata values. \\
\\For a given starting frequency and total mass, a time array is allocated based on an estimate of the waveform length. We use the LAL function 
\texttt{SimIMRSEOBNRv2ChirpTimeSingleSpin()} to estimate the waveform length with an additional leverage of 10\%. If the NR waveforms are not long
enough, the generation is aborted. From the estimated length and the desired sampling rate, the discrete time series for the spline evaluation is
determined.

To construct the polarisation $h_+$ and $h_\times$, the splines for each amplitude and phase are evaluated at the points in the discrete time times, 
weighted by the ${}^{-2}Y_{lm}$, and summed up:
\begin{align}
\label{}
    \mathrm{Re}(h_{\ell m}) &= A_{\ell m} \cos(\Phi_{\ell m}),   \\
    \mathrm{Im}(h_{\ell m}) &= A_{\ell m} \sin(\Phi_{\ell m}),   \\
    h_+ &= \sum_{\ell, m} \mathrm{Re}(h_{\ell m}) \mathrm{Re}({}^{-2}Y_{\ell m}) + \mathrm{Im}(h_{\ell m}) \mathrm{Im}({}^{-2}Y_{\ell m}), \\
    h_\times &= \sum_{\ell, m} \mathrm{Re}(h_{\ell m}) \mathrm{Im}({}^{-2}Y_{\ell m}) - \mathrm{Im}(h_{\ell m}) \mathrm{Re}({}^{-2}Y_{\ell m}),
\end{align}
where the polar angle $\theta$ denotes the angle between the orbital angular momentum and the line-of-sight and the azimuthal
angle $\phi$ is the sum of parameter value 'coa\textunderscore phase' and any reference phase passed in the waveform generator function.
\\
Note that all waveform modes $(\ell, m)$ contained in the HDF5 file are used
to compute the two polarisations. The algorithm will incorporate any mode between $\ell =2$ and $\ell =8$ if present in the
HDF5 file but at least the $(\ell=2, m=2)$ has to be present in the NR data file. \\
\\
The compressed NR data files do not store the splines themselves, but the knots, errors, the polynomial degree etc. In the pyCBC implementation,
the splines are constructed from the HDF5 file via the python function \texttt{UnivariateSpline}, in the LAL implementation regular GSL interpolation
is performed. Fig.~\ref{fig:waveforms} shows an example comparison between NR waveforms obtained using the pyCBC and the LAL waveform generators. The mismatch
between the waveforms is less than $10^{-7}$. This is consistent with the level of disagreement expected due to the different numerical interpolation
routines. \\
The source codes can be found in \texttt{lalsuite/lalsimulation/src/LALSimIMRNRWaveforms.c} and 
\texttt{pycbc/pycbc/waveforms/nr\textunderscore waveform.py} respectively.

%%%%%%%%%%
\subsection{Examples}
%%%%%%%%%%
There are a variety of different ways to generate waveforms using LIGO data analysis software. Here, we give two specific examples
for function calls in python, firstly directly via the pyCBC implementation, and secondly through the SWIG-wrapped version of 
lalsimulation. 

\begin{enumerate}
  \item The pyCBC implementation of the waveform generator may be called in the following way through python: \\
\begin{lstlisting}
from pycbc.waveform import get_td_waveform 

hp, hc = get_td_waveform(approximant='NR_hdf5', 
                         numrel_data='/PATH/TO/HDF5',
                         mass1, mass2,
                         spin1x, spin1y, spin1z,
                         spin2x, spin2y, spin2z, 
                         delta_t, f_lower, f_ref,
                         inclination, distance, 
                         coa_phase)
\end{lstlisting}

\item To use the implementation in LALSimulation through SWIG, use the following function call in python:\\
\begin{lstlisting}[mathescape=true]
import lalsimulation as lalsim

flags = lalsim.SimInspiralCreateWaveformFlags()

lalsim.SimInspiralSetNumrelData(flags,'/PATH/TO/HDF5')

hp, hc = lalsim.SimInspiralChooseTDWaveform(phiRef, 
              deltaT, m1 * MSUN_SI, m2 * MSUN_SI, 
              s1x, s1y, s1z,
              s2x, s2y, s2z, 
              fStart, fRef, 
              distance, inclination,
              $\lambda_1=0$, $\lambda_2=0$, 
              flags, nonGRparams=None, 
              amplitudeO=-1, phaseO=-1, 
              approximant=lalsim.NR_hdf5),
\end{lstlisting}
where $\lambda_1$ denote the tidal deformation parameters, which vanish in the case of black holes. 
\end{enumerate}
Fig.~\ref{fig:waveforms} shows the two waveform polarizations $h_+$ and $h_{\times}$ for the binary black hole hole case simulated in case 
SXS:BBH:0019 from the publicly available SXS catalogue~\cite{Mroue:2013xna} for a total mass of 50 $\mathrm{M}_\odot$. The dimensionless spins for this simulation are
$\vec{\chi}_1=(0,0,-0.5)$ and $\vec{\chi}_2=(0,0,0.499)$ and the component masses are $m_1=30.01360$ and $m_2=20.00954$.
As extrinsic parameters, we choose the following: distance=100Mpc, inclination=0.4rad, deltaT=1.0/16384, fStart=fRef=18.88Hz. We do not alter
the reference phase but instead pass the metadata value stored in the HDF5 file. We have obtained those polarizations via the lalsimulation interface and also via the test verification code in pycbc. The match between the waveforms obtained from the two numerical implementations is $\mathcal{M}=0.999999999341$.
\begin{figure}
\begin{center}
\includegraphics[width=80mm]{lalsim_TD_0019.png}
\includegraphics[width=80mm]{pycbc_TD_0019.png}
\caption{The waveform polarizations $h_+$(solid, red) and $h_\times$(dashed, blue) of the publicly available SXS waveform SXS:BBH:0019 
generated via the waveform interface in lalsimulation (left panel) and in pyCBC (right panel).}
\label{fig:waveforms}
\end{center}
\end{figure}


%%%%%%%%%%
\section{Discussion}
\label{sec:discussion}
%%%%%%%%%%

With this new infrastructure it should be much easier, and much less memory intensive, to use NR waveforms
directly for data-analysis applications. The ``NR\_hdf5'' approximant works much the same as any other approximants
in lalsimulation, but does have a few important differences. The user must supply the location of the HDF file
corresponding to the waveform to be injected, this functionality was already available from NINJA, but was not
previously used in lalsimulation. Second the user must be careful to supply mass ratio and spin values that
are consistent with the NR files. Small changes are therefore needed to use this approximant in applications
and we will be happy to assist with implementing such changes. PyCBC and lalinference already have test branches
where this is available.

There are also still a few caveats to the current implementation, which we plan to investigate with the waveform review committee.
As opposed to the continuous waveform approximants, at the moment the metadata
are only referring to the beginning of the waveform and not some reference time, which can be chosen freely. While this is 
not a problem for aligned-spin binaries, this poses a rather big problem for precessing simulations. To fully integrate this
desired freedom, additional information needs to be incorporated into the HDF5 files and the waveform generator
accordingly. In particular, the relevant information would have to include the spins as a function of frequency as well
as the orbital angular momentum direction. 

%%%%%%%%%%%%%%%%%%%%%%%%%Acknowledgements%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgments}
We thank Kent Blackburn for carefully reading through the manuscript and providing useful comments.

%%%%%%%%%%%%%%%%%%%%%%%%%Appendices%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
%%%%%%%%%
\section{Conventions and frame choices}
\label{sec:conv}
%%%%%%%%%%
The new infrastructure provides a standardised interface between NR and LIGO data analysis. To guarantee
the correct waveform handling, in particular for precessing binary simulations, certain conventions and frame
choices must be considered. 

The current setup is as follows: At the start of the waveform, i.e. the first entry in the NR time series considered in the
HDF5 file, the instantaneous orbital plane, characterized by its orthonormal direction $\hat{L}$, has some (arbitrary) orientation
in the Cartesian simulation frame $(x, y, z)$ of the NR simulation. The polar angle between the line-of-sight $\hat{N}$ and the instantaneous orbital angular momentum direction is denoted as $\theta$ and corresponds to the option parameter ``inclination'' in the waveform generator functions. 

If the NR simulation the frame is defined such that $\hat{L}$ does not point along the z-axis at the start of the waveform, the additional angle between $\hat{L}$ and the z-axis needs to be taken into account when setting the value for the inclination parameter. Currently, it is up to the user to take care of this, but we aim to integrate this into the waveform generator. 

The azimuthal angle $\phi$ denotes the instantaneous orientation of the orbital separation at the beginning of the waveform in the source frame, where $\hat{L}$ points along the z-axis. The metadata parameter ``coa\textunderscore phase'' is twice this angle.

\begin{figure}[!h]
\begin{center}
\def\svgwidth{0.4\columnwidth}
\input{SourceFrame.pdf_tex}
\caption{Binary source frame for spin and orbital phase measurements: The spins and orbital phase measurements at the
beginning of the NR data set have to be provided in a frame, where $\hat{L}$ points along the z-direction.}  
\label{fig:source}
\end{center}
\end{figure}

%%%%%References%%%%%%%%%%%%%%%%%

\bibliography{nrinj}

%%%%%%%%%%
\end{document}
%%%%%%%%%%
